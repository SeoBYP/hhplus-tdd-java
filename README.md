## 📝 TDD 학습

### 💡 개요 (Overview)

본 프로젝트는 TDD(Test-Driven Development) 방법론을 적용하여 사용자 포인트 시스템의 핵심 기능(조회, 충전, 사용)을 구현하고, 특히 **동시성(Concurrency) 문제**를 안전하게 해결하는 것을 목표로 했습니다.

#### 핵심 목표 및 해결 전략

1.  **데이터 정합성 확보:** 다수의 요청이 동시에 들어왔을 때 잔액 계산 오류(Race Condition)를 방지했습니다.
    * **해결:** `PointService`에 **`ConcurrentHashMap`과 `ReentrantLock`**을 사용하여 **사용자 ID별 메모리 락**을 구현했습니다. 동일 사용자 요청만 직렬화 처리하고 다른 사용자 요청은 병렬 처리하여 성능과 무결성을 동시에 확보했습니다.
2.  **테스트 용이성 확보 (시간 의존성 제거):** `PointHistory` 기록 시 시스템 시간에 의존하는 문제를 해결했습니다.
    * **해결:** `TimeProvider` 인터페이스와 **`FakeTimeProvider`**를 도입하여 테스트 코드에서 시간을 자유롭게 조작하며 히스토리 정렬 등 시간 관련 로직을 완벽하게 검증했습니다.
3.  **TDD 프로세스 적용:** 모든 로직은 **Red (실패) → Green (성공) → Refactor (개선)** 사이클에 맞춰 구현되었습니다.

---

### 💻 작업 방식: TDD 프로세스에 따른 구현 전략

모든 기능은 테스트 코드를 먼저 작성하고(Red), 이를 통과시키는 최소한의 프로덕션 코드(Green)를 작성하는 TDD 원칙을 따랐습니다. 특히, 복잡도가 높은 동시성 문제를 해결하기 위해 다음과 같은 단계별 전략을 사용했습니다.

#### 1. 기능 우선 TDD (기본 구조 및 비즈니스 로직)
* **작업 의도:** 가장 기본적이고 핵심적인 **도메인 요구사항(조회, 충전, 잔고 부족/음수 체크)**을 먼저 정의하고 구현하여 서비스의 뼈대를 완성했습니다. TDD를 통해 `PointService`가 어떤 기능을 제공해야 하는지 명확하게 정의하는 데 집중했습니다.
* **구현 단계:** 초기 환경 설정 후 `신규 유저 조회 시 0포인트 반환 테스트 코드 작성`을 시작으로, `포인트 차감/충전 Service Layer 구현`, `잔고 부족 예외`, `음수 충전/사용 불가` 등의 단위 테스트를 순차적으로 통과시키며 구현했습니다.

#### 2. 테스트 가능한 설계 적용 (시간 의존성 분리)
* **작업 의도:** 히스토리 조회 시 최신순 정렬이 요구되었기 때문에, 시간 정보가 외부 시스템(`System.currentTimeMillis()`)에 의존하는 것을 방지하여 테스트의 **비결정성(Non-determinism)**을 제거했습니다.
* **구현 단계:** `TimeProvider` 인터페이스를 설계하고 `FakeTimeProvider`를 만들어 DI(Dependency Injection)를 통해 주입받도록 구조를 변경했습니다. 이는 `2회 이상 충전 시 최신순으로 정렬된 값을 반환하는 테스트 코드 작성`을 성공시키는 핵심 기반이 되었습니다.

#### 3. 동시성 테스트 주도 개발 (Lock 도입)
* **작업 의도:** 가장 중요한 요구사항인 동시성 문제를 해결하기 위해, 먼저 **Lock이 없는 상태에서 실패하는 테스트**를 작성하여 문제 상황을 명확히 정의했습니다.
* **구현 단계:**
    1.  **Red (문제 정의):** `UserPointTableTest.java`에 **`CountDownLatch`와 `ExecutorService`**를 사용하여 `동시성 테스트 코드 실패` 케이스를 구현했습니다. 이 테스트는 Lock이 없기 때문에 데이터가 유실되어 잔액이 기대값(예: 2000)보다 적게 나오는 것을 확인하는 역할을 했습니다.
    2.  **Green (솔루션 적용):** 실패하는 테스트를 통과시키기 위해 `PointService`에 **사용자별 `ReentrantLock`** 로직을 추가했습니다.
    3.  **Refactor & 검증:** Lock 적용 후 `동시성 테스트 코드 성공`을 확인하고, 실제 API 환경에서 검증하기 위해 `feature/TDD 동시성 통합 테스트 코드 구현`까지 진행하여 최종적으로 정합성을 확인했습니다.

---

### 🌱 알게 된 점 (Learned Points)

#### 1. TDD 프로세스의 이해도 증진
* 단순히 테스트 코드를 먼저 작성하는 것을 넘어, **테스트 코드가 구현 코드의 설계를 이끌어내고** 의존성을 분리(TimeProvider)하는 핵심적인 역할을 한다는 TDD 프로세스의 본질적인 이해도를 높였습니다.
* **셀프 피드백:** 초기에는 TDD 분기 작업에 미흡함이 있었으나, **구현된 코드를 바탕으로 TDD 사이클에 맞춰 커밋을 재구성**하면서, 작업 단위별 테스트 작성의 중요성을 깊이 체감했습니다.

#### 2. Java Concurrency API 및 패턴의 실전 적용
* Java 환경에서 **`ReentrantLock`을 `ConcurrentHashMap`으로 관리**하는 사용자별 락 패턴을 서비스 레이어에 적용하는 방법을 숙달했습니다.
* `ExecutorService`, `CountDownLatch` 등 Concurrency API를 활용하여 멀티스레드 환경을 구축하고 테스트하는 실전 경험을 쌓았습니다.

#### 3. 테스트 환경 구축 및 의존성 분리
* 시스템 시간 의존성을 완벽하게 분리한 `TimeProvider` 패턴은 테스트 코드의 **결정론적(Deterministic)** 실행을 보장하는 우수 설계 패턴임을 확인했습니다.
* 인메모리 테이블을 사용하면서도 동시성 문제까지 완벽하게 테스트하는 환경을 구축함으로써, **Mocking 없는 단위 테스트**의 강력함을 확인했습니다.
